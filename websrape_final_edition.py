# -*- coding: utf-8 -*-
"""Websrape Final edition

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vGrcSFpQXyOVkLmj9M7fSCv6jGXcZSif
"""

# Install required packages
!pip install requests beautifulsoup4 pandas lxml

print("Packages installed successfully!")



!pip install requests pandas openpyxl
print("‚úÖ Packages installed for Excel export!")

# Complete updated Google Places scraper with Excel functions
import requests
import pandas as pd
import json
import time
from dataclasses import dataclass, asdict
from typing import List, Optional

@dataclass
class Business:
    name: str = ""
    phone: str = ""
    email: str = ""
    address: str = ""
    zip_code: str = ""
    services: List[str] = None
    website: str = ""
    rating: float = 0.0
    total_ratings: int = 0
    price_level: str = ""
    source_url: str = "Google Places API"
    place_id: str = ""
    # New categorization fields
    primary_category: str = ""
    all_categories: List[str] = None
    service_keywords: List[str] = None

    def __post_init__(self):
        if self.services is None:
            self.services = []
        if self.all_categories is None:
            self.all_categories = []
        if self.service_keywords is None:
            self.service_keywords = []

class GooglePlacesScraper:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://maps.googleapis.com/maps/api/place"
        self.businesses = []

    def search_nearby_businesses(self, location, search_terms, radius=50000):
        coords = self.get_coordinates(location)
        if not coords:
            print(f"‚ùå Could not find coordinates for {location}")
            return

        print(f"üìç Searching near {location} ({coords['lat']}, {coords['lng']})")

        for term in search_terms:
            print(f"\nüîç Searching for: {term}")
            self.search_places(coords, term, radius)
            time.sleep(1)

    def get_coordinates(self, address):
        geocode_url = f"{self.base_url}/findplacefromtext/json"

        params = {
            'input': address,
            'inputtype': 'textquery',
            'fields': 'geometry',
            'key': self.api_key
        }

        try:
            response = requests.get(geocode_url, params=params)
            data = response.json()

            if data['status'] == 'OK' and data['candidates']:
                location = data['candidates'][0]['geometry']['location']
                return {'lat': location['lat'], 'lng': location['lng']}
            else:
                print(f"Geocoding error: {data.get('status', 'Unknown error')}")
                return None

        except Exception as e:
            print(f"Error getting coordinates: {e}")
            return None

    def search_places(self, coordinates, keyword, radius):
        search_url = f"{self.base_url}/nearbysearch/json"

        params = {
            'location': f"{coordinates['lat']},{coordinates['lng']}",
            'radius': radius,
            'keyword': keyword,
            'key': self.api_key
        }

        try:
            response = requests.get(search_url, params=params)
            data = response.json()

            if data['status'] == 'OK':
                places = data.get('results', [])
                print(f"  Found {len(places)} places")

                for place in places:
                    business = self.parse_place_data(place)
                    if business:
                        detailed_business = self.get_place_details(business.place_id, business)
                        self.businesses.append(detailed_business)

            else:
                print(f"  Search error: {data.get('status')} - {data.get('error_message', '')}")

        except Exception as e:
            print(f"  Search failed: {e}")

    def parse_place_data(self, place):
        try:
            business = Business()
            business.name = place.get('name', '')
            business.place_id = place.get('place_id', '')
            business.rating = place.get('rating', 0.0)
            business.total_ratings = place.get('user_ratings_total', 0)

            price_level = place.get('price_level')
            if price_level is not None:
                price_symbols = ['Free', '$', '$$', '$$$', '$$$$']
                business.price_level = price_symbols[price_level] if price_level < len(price_symbols) else ''

            business.services = place.get('types', [])
            business.address = place.get('vicinity', '')

            return business

        except Exception as e:
            print(f"  Error parsing place: {e}")
            return None

    def get_place_details(self, place_id, business):
        details_url = f"{self.base_url}/details/json"

        params = {
            'place_id': place_id,
            'fields': 'formatted_phone_number,website,formatted_address,address_components,international_phone_number',
            'key': self.api_key
        }

        try:
            response = requests.get(details_url, params=params)
            data = response.json()

            if data['status'] == 'OK':
                result = data['result']

                business.phone = result.get('formatted_phone_number', '')
                business.website = result.get('website', '')
                business.address = result.get('formatted_address', business.address)

                address_components = result.get('address_components', [])
                for component in address_components:
                    if 'postal_code' in component.get('types', []):
                        business.zip_code = component['long_name']
                        break

            return business

        except Exception as e:
            print(f"  Error getting details: {e}")
            return business

    def categorize_services(self):
        """Add service categories and keywords to businesses"""

        service_categories = {
            'Food Assistance': [
                'food bank', 'emergency food', 'food delivery seniors', 'meal', 'food for disability', 'food pantry', 'food for all in need',
                'families', 'disabled', 'individuals', 'help pay for food', 'SNAP', 'food stamps', 'nutrition education',
                'government food benefits', 'low-income', 'veterans', 'in crisis', 'help pay for food', 'food banks', 'food delivery'
            ],
            'Housing': [
                'housing assistance', 'help pay for housing', 'government benefits', 'housing vouchers', 'help pay for housing',
                'low-income', 'help pay for housing',
                'teens', 'help pay for internet', 'female', 'felon-friendly', 'adults with kids', 'help pay for phone', 'help pay for utilities',
                'utility assistance', 'assisted living', 'independent living', 'sober living', 'shelter', 'Temporary Housing'
            ],
            'Healthcare': [
                'doctor', 'dentist', 'medical', 'health', 'clinic', 'hospital', 'pharmacy',
                'dental', 'physician', 'therapy', 'physical', 'mental', 'wellness',
                'physiotherapist', 'chiropractor', 'optometrist', 'veterinary', 'medicaid', 'peer support', 'case management','womens health',
                'crisis management', 'health insurance', 'prescription assistance', 'healthcare transportation','health insurance','occupational therapy',
                'physical therapy', 'medical management', 'speech therapy', 'psychological evaluations', 'vaccinations'
            ],
            'Beauty & Personal Care': [
                'hair', 'salon', 'barber', 'beauty', 'spa', 'nail', 'massage', 'skincare',
                'cosmetic', 'facial', 'manicure', 'pedicure', 'styling'
            ],
            'Legal Services': [
                'lawyer', 'attorney', 'legal', 'immigration help', 'legal aid and advocacy', 'adoption and foster care', 'workplace rights',
                'translastion and interpretation', 'financial', 'bank', 'loan', 'mortgage', 'investment'
            ],
            'Employment': [
                'job placement assistance', 'supported employment', 'clothes for work', 'unemployment benefits', 'electronics', 'grocery',
                'skills and training', 'Idaho Launch'
            ]

        }

        for business in self.businesses:
            business_text = ' '.join(business.services).lower() + ' ' + business.name.lower()

            matched_categories = []
            matched_keywords = []

            for category, keywords in service_categories.items():
                category_matches = []
                for keyword in keywords:
                    if keyword.lower() in business_text:
                        category_matches.append(keyword)

                if category_matches:
                    matched_categories.append(category)
                    matched_keywords.extend(category_matches)

            business.primary_category = matched_categories[0] if matched_categories else 'Other'
            business.all_categories = matched_categories
            business.service_keywords = list(set(matched_keywords))

        print("‚úÖ Service categorization complete!")

    def create_keyword_analysis_excel(self, filename="business_keyword_analysis.xlsx"):
        """Create an Excel file with keyword analysis for easy filtering"""
        if not self.businesses:
            print("No businesses to save")
            return

        self.categorize_services()

        # Create main dataframe
        data = []
        for business in self.businesses:
            keywords = business.service_keywords if business.service_keywords else ['No Keywords']

            for keyword in keywords:
                data.append({
                    'Business Name': business.name,
                    'Keyword': keyword,
                    'Primary Category': business.primary_category,
                    'Phone': business.phone,
                    'Address': business.address,
                    'Rating': business.rating,
                    'Total Reviews': business.total_ratings,
                    'Website': business.website,
                    'All Keywords': ', '.join(business.service_keywords),
                    'All Services': ', '.join(business.services)
                })

        df = pd.DataFrame(data)

        with pd.ExcelWriter(filename, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='Keyword Analysis', index=False)

            keyword_counts = df['Keyword'].value_counts().reset_index()
            keyword_counts.columns = ['Keyword', 'Count']
            keyword_counts.to_excel(writer, sheet_name='Keyword Frequency', index=False)

            category_keywords = df.groupby(['Primary Category', 'Keyword']).size().reset_index(name='Count')
            category_keywords.to_excel(writer, sheet_name='Category Keywords', index=False)

        print(f"‚úÖ Created keyword analysis Excel: {filename}")
        print("This file lets you filter by any keyword to see matching businesses")

    def remove_duplicates(self):
        seen = set()
        unique_businesses = []

        for business in self.businesses:
            key = (business.name.lower(), business.phone)
            if key not in seen:
                seen.add(key)
                unique_businesses.append(business)

        removed = len(self.businesses) - len(unique_businesses)
        self.businesses = unique_businesses
        print(f"Removed {removed} duplicates, {len(self.businesses)} unique businesses")

print("‚úÖ Updated GooglePlacesScraper loaded with Excel functions!")

# Complete updated Google Places scraper with Excel functions
import requests
import pandas as pd
import json
import time
from dataclasses import dataclass, asdict
from typing import List, Optional

@dataclass
class Business:
    name: str = ""
    phone: str = ""
    email: str = ""
    address: str = ""
    zip_code: str = ""
    services: List[str] = None
    website: str = ""
    rating: float = 0.0
    total_ratings: int = 0
    price_level: str = ""
    source_url: str = "Google Places API"
    place_id: str = ""
    # New categorization fields
    primary_category: str = ""
    all_categories: List[str] = None
    service_keywords: List[str] = None

    def __post_init__(self):
        if self.services is None:
            self.services = []
        if self.all_categories is None:
            self.all_categories = []
        if self.service_keywords is None:
            self.service_keywords = []

class GooglePlacesScraper:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://maps.googleapis.com/maps/api/place"
        self.businesses = []

    def search_nearby_businesses(self, location, search_terms, radius=50000):
        coords = self.get_coordinates(location)
        if not coords:
            print(f"‚ùå Could not find coordinates for {location}")
            return

        print(f"üìç Searching near {location} ({coords['lat']}, {coords['lng']})")

        for term in search_terms:
            print(f"\nüîç Searching for: {term}")
            self.search_places(coords, term, radius)
            time.sleep(1)

    def get_coordinates(self, address):
        geocode_url = f"{self.base_url}/findplacefromtext/json"

        params = {
            'input': address,
            'inputtype': 'textquery',
            'fields': 'geometry',
            'key': self.api_key
        }

        try:
            response = requests.get(geocode_url, params=params)
            data = response.json()

            if data['status'] == 'OK' and data['candidates']:
                location = data['candidates'][0]['geometry']['location']
                return {'lat': location['lat'], 'lng': location['lng']}
            else:
                print(f"Geocoding error: {data.get('status', 'Unknown error')}")
                return None

        except Exception as e:
            print(f"Error getting coordinates: {e}")
            return None

    def search_places(self, coordinates, keyword, radius):
        search_url = f"{self.base_url}/nearbysearch/json"

        params = {
            'location': f"{coordinates['lat']},{coordinates['lng']}",
            'radius': radius,
            'keyword': keyword,
            'key': self.api_key
        }

        try:
            response = requests.get(search_url, params=params)
            data = response.json()

            if data['status'] == 'OK':
                places = data.get('results', [])
                print(f"  Found {len(places)} places")

                for place in places:
                    business = self.parse_place_data(place)
                    if business:
                        detailed_business = self.get_place_details(business.place_id, business)
                        self.businesses.append(detailed_business)

            else:
                print(f"  Search error: {data.get('status')} - {data.get('error_message', '')}")

        except Exception as e:
            print(f"  Search failed: {e}")

    def parse_place_data(self, place):
        try:
            business = Business()
            business.name = place.get('name', '')
            business.place_id = place.get('place_id', '')
            business.rating = place.get('rating', 0.0)
            business.total_ratings = place.get('user_ratings_total', 0)

            price_level = place.get('price_level')
            if price_level is not None:
                price_symbols = ['Free', '$', '$$', '$$$', '$$$$']
                business.price_level = price_symbols[price_level] if price_level < len(price_symbols) else ''

            business.services = place.get('types', [])
            business.address = place.get('vicinity', '')

            return business

        except Exception as e:
            print(f"  Error parsing place: {e}")
            return None

    def get_place_details(self, place_id, business):
        details_url = f"{self.base_url}/details/json"

        params = {
            'place_id': place_id,
            'fields': 'formatted_phone_number,website,formatted_address,address_components,international_phone_number',
            'key': self.api_key
        }

        try:
            response = requests.get(details_url, params=params)
            data = response.json()

            if data['status'] == 'OK':
                result = data['result']

                business.phone = result.get('formatted_phone_number', '')
                business.website = result.get('website', '')
                business.address = result.get('formatted_address', business.address)

                address_components = result.get('address_components', [])
                for component in address_components:
                    if 'postal_code' in component.get('types', []):
                        business.zip_code = component['long_name']
                        break

            return business

        except Exception as e:
            print(f"  Error getting details: {e}")
            return business

    def categorize_services(self):
        """Add service categories and keywords to businesses"""

        service_categories = {
            'Food Assistance': [
                'food bank', 'emergency food', 'food delivery seniors', 'meal', 'food for disability', 'food pantry', 'food for all in need',
                'families', 'disabled', 'individuals', 'help pay for food', 'SNAP', 'food stamps', 'nutrition education',
                'government food benefits', 'low-income', 'veterans', 'in crisis', 'help pay for food', 'food banks', 'food delivery'
            ],
            'Housing': [
                'housing assistance', 'help pay for housing', 'government benefits', 'housing vouchers', 'help pay for housing',
                'low-income', 'help pay for housing',
                'teens', 'help pay for internet', 'female', 'felon-friendly', 'adults with kids', 'help pay for phone', 'help pay for utilities',
                'utility assistance', 'assisted living', 'independent living', 'sober living', 'shelter', 'Temporary Housing'
            ],
            'Healthcare': [
                'doctor', 'dentist', 'medical', 'health', 'clinic', 'hospital', 'pharmacy',
                'dental', 'physician', 'therapy', 'physical', 'mental', 'wellness',
                'physiotherapist', 'chiropractor', 'optometrist', 'veterinary', 'medicaid', 'peer support', 'case management','womens health',
                'crisis management', 'health insurance', 'prescription assistance', 'healthcare transportation','health insurance','occupational therapy',
                'physical therapy', 'medical management', 'speech therapy', 'psychological evaluations', 'vaccinations'
            ],

            'Legal Services': [
                'lawyer', 'attorney', 'legal', 'immigration help', 'legal aid and advocacy', 'adoption and foster care', 'workplace rights',
                'translastion and interpretation', 'financial', 'bank', 'loan', 'mortgage', 'investment'
            ],
            'Employment': [
                'job placement assistance', 'supported employment', 'clothes for work', 'unemployment benefits', 'electronics', 'grocery',
                'skills and training', 'Idaho Launch','job search assistance','employment for disabled','temporary employment agencies'
            ],
            'Supplies': {
                'Meidcal Equpment','anyone in need','all ages','medical supplies','assistive technology','daily life skills','counseling','in-home support',
                'low-income','health education','baby supplies'
            },
            'Transportation': {
                'help pay for transportation','bus passes','help pay for car','help pay for gas','transportaion for healthcare',
                'transportation for school'
            },
            'Education':{
                'help find school','help pay for school','financial aid counseling','financial aid and loans','supplies for school',
                'alternative education','GED help','nutrition education','sex education','tutoring','supported employment','english as a second language (ESL)',
                'family planning','health education','college readiness','foreclosure education','parenting education','financial education','colleges','community colleges',
                'high-school equivalency/ged','preschools','screening exams','citizenship and immigration','computer classes','daily life skills training',
                'interview training','resume workshops','skills assesment','specialized training'

            },
            'Financial Assistance': {
                'help pay for childcare','help pay for food','government food benefits','help pay for healthcare','disability benefits','discounted healthcare',
                'health insurance','prescription assistance','help pay for housing','help pay for internet','help pay for phone','help pay for school',
                'help pay for gas','credit counseling','disability benefits','government benefits','retirement benefits','unemployment benefits',
                'business loans','personal loans','tax preparation'
            }
        }

        for business in self.businesses:
            business_text = ' '.join(business.services).lower() + ' ' + business.name.lower()

            matched_categories = []
            matched_keywords = []

            for category, keywords in service_categories.items():
                category_matches = []
                for keyword in keywords:
                    if keyword.lower() in business_text:
                        category_matches.append(keyword)

                if category_matches:
                    matched_categories.append(category)
                    matched_keywords.extend(category_matches)

            business.primary_category = matched_categories[0] if matched_categories else 'Other'
            business.all_categories = matched_categories
            business.service_keywords = list(set(matched_keywords))

        print("‚úÖ Service categorization complete!")

    def create_keyword_analysis_excel(self, filename="business_keyword_analysis.xlsx"):
        """Create an Excel file with keyword analysis for easy filtering"""
        if not self.businesses:
            print("No businesses to save")
            return

        self.categorize_services()

        # Create main dataframe
        data = []
        for business in self.businesses:
            keywords = business.service_keywords if business.service_keywords else ['No Keywords']

            for keyword in keywords:
                data.append({
                    'Business Name': business.name,
                    'Keyword': keyword,
                    'Primary Category': business.primary_category,
                    'Phone': business.phone,
                    'Address': business.address,
                    'Rating': business.rating,
                    'Total Reviews': business.total_ratings,
                    'Website': business.website,
                    'All Keywords': ', '.join(business.service_keywords),
                    'All Services': ', '.join(business.services)
                })

        df = pd.DataFrame(data)

        with pd.ExcelWriter(filename, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='Keyword Analysis', index=False)

            keyword_counts = df['Keyword'].value_counts().reset_index()
            keyword_counts.columns = ['Keyword', 'Count']
            keyword_counts.to_excel(writer, sheet_name='Keyword Frequency', index=False)

            category_keywords = df.groupby(['Primary Category', 'Keyword']).size().reset_index(name='Count')
            category_keywords.to_excel(writer, sheet_name='Category Keywords', index=False)

        print(f"‚úÖ Created keyword analysis Excel: {filename}")
        print("This file lets you filter by any keyword to see matching businesses")

    def remove_duplicates(self):
        seen = set()
        unique_businesses = []

        for business in self.businesses:
            key = (business.name.lower(), business.phone)
            if key not in seen:
                seen.add(key)
                unique_businesses.append(business)

        removed = len(self.businesses) - len(unique_businesses)
        self.businesses = unique_businesses
        print(f"Removed {removed} duplicates, {len(self.businesses)} unique businesses")

print("‚úÖ Updated GooglePlacesScraper loaded with Excel functions!")

API_KEY = "AIzaSyCdWcWrNJ-2sMZewvs2Br4B_DhQilVunrI"
scraper = GooglePlacesScraper(API_KEY)

# Do a broad search to get lots of businesses
search_terms = [
  "food bank", "emergency food", "food delivery seniors", "meal", "food for disability", "food pantry", "food for all in need",
  "food for families", "disabled", "individuals", "help pay for food", "SNAP", "food stamps", "nutrition education",
  "government food benefits", "low-income food assistance", "veterans", "in crisis", "help pay for food", "food banks", 'food delivery for people in need'

]

location = "Boise, ID"
print(f"üîç Starting broad search in {location}...")

scraper.search_nearby_businesses(location, search_terms, radius=50000)
scraper.remove_duplicates()

print(f"üìä Found {len(scraper.businesses)} unique businesses")

# Create the keyword analysis Excel file
scraper.create_keyword_analysis_excel("boise_food_scraper.xlsx")

# Download it
from google.colab import files
files.download('boise_food_scraper.xlsx')

print("‚úÖ Done! Check your downloads folder for the Excel file.")